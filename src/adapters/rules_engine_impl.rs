//! Rules evaluation engine adapter
//!
//! Implements the RulesEngine port trait. Evaluates court rules against
//! filing contexts by selecting applicable rules, resolving priority,
//! recursively evaluating conditions, and collecting actions into a
//! compliance report.

use crate::domain::deadline_calc::DeadlineResult;
use crate::domain::filing_pipeline::{ComplianceReport, FilingContext, RuleResult};
use crate::domain::rule::{Rule, RuleAction, RuleCondition, TriggerEvent};
use crate::error::ApiError;
use crate::ports::rules_engine::RulesEngine;
use chrono::Utc;

/// Spin-compatible rules evaluation engine
///
/// Stateless engine that evaluates court rules against filing contexts.
/// All state is passed in via method arguments.
pub struct SpinRulesEngine;

impl SpinRulesEngine {
    pub fn new() -> Self {
        Self
    }
}

impl SpinRulesEngine {
    /// Retrieve a field value from the filing context
    ///
    /// Checks direct struct fields first (case_type, document_type, etc.),
    /// then falls back to the metadata JSON object.
    fn get_field_value<'a>(&self, field: &str, context: &'a FilingContext) -> Option<String> {
        match field {
            "case_type" => Some(context.case_type.clone()),
            "document_type" => Some(context.document_type.clone()),
            "filer_role" => Some(context.filer_role.clone()),
            "jurisdiction_id" => Some(context.jurisdiction_id.clone()),
            "division" => context.division.clone(),
            "assigned_judge" => context.assigned_judge.clone(),
            _ => {
                // Look up in metadata JSON
                context.metadata.get(field).and_then(|v| {
                    match v {
                        serde_json::Value::String(s) => Some(s.clone()),
                        serde_json::Value::Number(n) => Some(n.to_string()),
                        serde_json::Value::Bool(b) => Some(b.to_string()),
                        _ => Some(v.to_string()),
                    }
                })
            }
        }
    }

    /// Check whether a field exists in the filing context
    fn field_exists(&self, field: &str, context: &FilingContext) -> bool {
        match field {
            "case_type" | "document_type" | "filer_role" | "jurisdiction_id" => true,
            "division" => context.division.is_some(),
            "assigned_judge" => context.assigned_judge.is_some(),
            "service_method" => context.service_method.is_some(),
            _ => {
                context.metadata.get(field).map_or(false, |v| !v.is_null())
            }
        }
    }

    /// Process a matched rule's actions and append results to the report
    fn process_actions(
        &self,
        rule: &Rule,
        report: &mut ComplianceReport,
    ) {
        for action in &rule.actions {
            match action {
                RuleAction::BlockFiling { reason } => {
                    report.blocked = true;
                    report.block_reasons.push(format!(
                        "[{}] {}",
                        rule.name, reason
                    ));
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "block_filing".to_string(),
                        message: reason.clone(),
                    });
                }
                RuleAction::FlagForReview { reason } => {
                    report.warnings.push(format!(
                        "[{}] {}",
                        rule.name, reason
                    ));
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "flag_for_review".to_string(),
                        message: reason.clone(),
                    });
                }
                RuleAction::GenerateDeadline {
                    description,
                    days_from_trigger,
                } => {
                    let today = Utc::now().date_naive();
                    let due_date = today + chrono::Duration::days(*days_from_trigger as i64);
                    report.deadlines.push(DeadlineResult {
                        due_date,
                        description: description.clone(),
                        rule_citation: rule.citation.clone().unwrap_or_default(),
                        computation_notes: format!(
                            "Generated by rule '{}': {} days from trigger",
                            rule.name, days_from_trigger
                        ),
                        is_short_period: *days_from_trigger <= 14,
                    });
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "generate_deadline".to_string(),
                        message: format!(
                            "{} (due {})",
                            description, due_date
                        ),
                    });
                }
                RuleAction::RequireRedaction { fields } => {
                    let field_list = fields.join(", ");
                    report.warnings.push(format!(
                        "[{}] Redaction required for: {}",
                        rule.name, field_list
                    ));
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "require_redaction".to_string(),
                        message: format!("Redaction required for: {}", field_list),
                    });
                }
                RuleAction::SendNotification {
                    recipient,
                    message,
                } => {
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "send_notification".to_string(),
                        message: format!("Notify {}: {}", recipient, message),
                    });
                }
                RuleAction::RequireFee {
                    amount_cents,
                    description,
                } => {
                    let dollars = *amount_cents as f64 / 100.0;
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "require_fee".to_string(),
                        message: format!(
                            "{}: ${:.2}",
                            description, dollars
                        ),
                    });
                }
                RuleAction::LogCompliance { message } => {
                    report.results.push(RuleResult {
                        rule_id: rule.id,
                        rule_name: rule.name.clone(),
                        matched: true,
                        action_taken: "log_compliance".to_string(),
                        message: message.clone(),
                    });
                }
            }
        }
    }
}

impl RulesEngine for SpinRulesEngine {
    fn evaluate(
        &self,
        context: &FilingContext,
        rules: &[Rule],
    ) -> Result<ComplianceReport, ApiError> {
        let mut report = ComplianceReport {
            results: Vec::new(),
            blocked: false,
            block_reasons: Vec::new(),
            warnings: Vec::new(),
            deadlines: Vec::new(),
        };

        // Rules should already be selected and sorted by the caller,
        // but we still process them in the order given (priority-sorted)
        for rule in rules {
            // Evaluate all conditions (AND them together)
            let all_conditions_match = if rule.conditions.is_empty() {
                // No conditions means the rule always matches
                true
            } else {
                rule.conditions.iter().all(|condition| {
                    self.evaluate_condition(condition, context)
                })
            };

            if all_conditions_match {
                self.process_actions(rule, &mut report);
            } else {
                // Record non-matching rule for audit trail
                report.results.push(RuleResult {
                    rule_id: rule.id,
                    rule_name: rule.name.clone(),
                    matched: false,
                    action_taken: "none".to_string(),
                    message: "Conditions not met".to_string(),
                });
            }
        }

        Ok(report)
    }

    fn select_rules(
        &self,
        jurisdiction: &str,
        trigger: &TriggerEvent,
        all_rules: &[Rule],
    ) -> Vec<Rule> {
        let jurisdiction_lower = jurisdiction.to_lowercase();

        all_rules
            .iter()
            .filter(|rule| {
                // Rule must be currently in effect
                if !rule.is_in_effect() {
                    return false;
                }

                // Jurisdiction: matches if rule has no jurisdiction (global)
                // or rule jurisdiction matches the provided one
                let jurisdiction_match = rule.jurisdiction.as_ref().map_or(true, |j| {
                    j.to_lowercase() == jurisdiction_lower
                });

                if !jurisdiction_match {
                    return false;
                }

                // Rule must contain the given trigger event
                rule.triggers.contains(trigger)
            })
            .cloned()
            .collect()
    }

    fn resolve_priority(&self, mut matching_rules: Vec<Rule>) -> Vec<Rule> {
        matching_rules.sort_by(|a, b| b.priority.weight().cmp(&a.priority.weight()));
        matching_rules
    }

    fn evaluate_condition(
        &self,
        condition: &RuleCondition,
        context: &FilingContext,
    ) -> bool {
        match condition {
            RuleCondition::And { conditions } => {
                conditions.iter().all(|c| self.evaluate_condition(c, context))
            }
            RuleCondition::Or { conditions } => {
                conditions.iter().any(|c| self.evaluate_condition(c, context))
            }
            RuleCondition::Not { condition } => {
                !self.evaluate_condition(condition, context)
            }
            RuleCondition::FieldEquals { field, value } => {
                self.get_field_value(field, context)
                    .map_or(false, |v| v == *value)
            }
            RuleCondition::FieldContains { field, value } => {
                self.get_field_value(field, context)
                    .map_or(false, |v| v.contains(value.as_str()))
            }
            RuleCondition::FieldExists { field } => {
                self.field_exists(field, context)
            }
            RuleCondition::FieldGreaterThan { field, value } => {
                self.get_field_value(field, context).map_or(false, |v| {
                    match (v.parse::<f64>(), value.parse::<f64>()) {
                        (Ok(field_num), Ok(threshold)) => field_num > threshold,
                        _ => v.as_str() > value.as_str(),
                    }
                })
            }
            RuleCondition::FieldLessThan { field, value } => {
                self.get_field_value(field, context).map_or(false, |v| {
                    match (v.parse::<f64>(), value.parse::<f64>()) {
                        (Ok(field_num), Ok(threshold)) => field_num < threshold,
                        _ => v.as_str() < value.as_str(),
                    }
                })
            }
            RuleCondition::Always => true,
        }
    }
}
